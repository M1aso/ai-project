name: CI

on:
  push:
    branches: [ main, dev ]
    tags:
      - "release-*"
  pull_request:
    branches: [ main, dev ]

env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '20'

jobs:
  # Contract validation with live services
  contracts_lint:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install OpenAPI validation tools
        run: |
          echo "🔧 Installing OpenAPI validation tools..."
          npm config set registry https://registry.npmjs.org/
          npm cache clean --force
          
          # Try multiple package options with better error handling
          if npm install -g spectral-cli --verbose; then
            echo "✅ Spectral CLI installed successfully"
          elif npm install -g @apidevtools/swagger-cli --verbose; then
            echo "✅ Swagger CLI installed as fallback"
          else
            echo "⚠️ OpenAPI validation tools installation failed, using basic validation"
          fi

      - name: Setup Python environment
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: |
            requirements.txt
            services/*/requirements.txt

      - name: Install Python dependencies
        run: |
          echo "📦 Installing Python dependencies..."
          pip install --upgrade pip
          pip install fastapi uvicorn sqlalchemy psycopg2-binary redis jinja2
          
          # Install main requirements
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          fi
          
          # Install service-specific requirements
          if [ -f services/notifications/requirements.txt ]; then
            pip install -r services/notifications/requirements.txt
          fi

      - name: Start services for OpenAPI generation
        id: services
        run: |
          echo "🚀 Starting services for live OpenAPI generation..."
          
          # Service configuration
          declare -A SERVICES=(
            ["auth"]="8001"
            ["profile"]="8002" 
            ["analytics"]="8003"
            ["notifications"]="8004"
          )
          
          SERVICE_PIDS=()
          
          # Start services in parallel
          for service in "${!SERVICES[@]}"; do
            port=${SERVICES[$service]}
            echo "🔄 Starting $service service on port $port..."
            
            if [ -d "services/$service" ]; then
              (cd "services/$service" && CI=true python -m uvicorn app.main:app --host 0.0.0.0 --port "$port") &
              pid=$!
              SERVICE_PIDS+=($pid)
              echo "✅ $service service started with PID: $pid"
            else
              echo "⚠️ Service directory services/$service not found, skipping"
            fi
          done
          
          # Store PIDs for cleanup
          echo "${SERVICE_PIDS[*]}" > /tmp/service_pids
          echo "pids=${SERVICE_PIDS[*]}" >> $GITHUB_OUTPUT
          
          # Health check with timeout
          echo "🔍 Waiting for services to be ready..."
          for service in "${!SERVICES[@]}"; do
            port=${SERVICES[$service]}
            echo "Checking $service on port $port..."
            
            if timeout 30s bash -c "until curl -sf http://localhost:$port/healthz > /dev/null 2>&1; do sleep 1; done"; then
              echo "✅ $service service ready on port $port"
            else
              echo "⚠️ $service service not ready on port $port (timeout)"
            fi
          done
          
          echo "✅ Service startup completed"

      - name: Validate OpenAPI specifications
        run: |
          echo "🔍 Validating live OpenAPI specifications..."
          
          # Service configuration
          declare -A SERVICES=(
            ["auth"]="8001"
            ["profile"]="8002"
            ["analytics"]="8003" 
            ["notifications"]="8004"
          )
          
          # Validation function
          validate_service_spec() {
            local service=$1
            local port=$2
            local endpoint="http://localhost:$port/api/$service/openapi.json"
            
            echo "🔍 Validating $service OpenAPI spec..."
            
            # Check if endpoint is accessible
            if ! curl -sf "$endpoint" > /dev/null 2>&1; then
              echo "❌ $service OpenAPI endpoint not accessible: $endpoint"
              return 1
            fi
            
            # Try different validation tools
            if command -v spectral >/dev/null 2>&1; then
              if [ -f "libs/contracts/.spectral.yaml" ]; then
                spectral lint "$endpoint" --ruleset libs/contracts/.spectral.yaml -f stylish -D --fail-severity=error
              else
                spectral lint "$endpoint" -f stylish -D --fail-severity=error
              fi
            elif command -v swagger-cli >/dev/null 2>&1; then
              swagger-cli validate "$endpoint"
            else
              # Basic JSON validation
              if curl -sf "$endpoint" | jq . > /dev/null 2>&1; then
                echo "✅ $service OpenAPI spec is valid JSON"
                return 0
              else
                echo "❌ $service OpenAPI spec is not valid JSON"
                return 1
              fi
            fi
          }
          
          # Run validations in parallel
          validation_pids=()
          for service in "${!SERVICES[@]}"; do
            validate_service_spec "$service" "${SERVICES[$service]}" &
            validation_pids+=($!)
          done
          
          # Wait for all validations and collect results
          failed_services=()
          for i in "${!validation_pids[@]}"; do
            if ! wait "${validation_pids[$i]}"; then
              failed_services+=("${!SERVICES[@]:$i:1}")
            fi
          done
          
          # Report results
          if [ ${#failed_services[@]} -eq 0 ]; then
            echo "🎉 All OpenAPI specifications validated successfully!"
          else
            echo "❌ OpenAPI validation failed for: ${failed_services[*]}"
            exit 1
          fi

      - name: Cleanup services
        if: always()
        run: |
          echo "🧹 Cleaning up services..."
          if [ -f /tmp/service_pids ]; then
            SERVICE_PIDS=$(cat /tmp/service_pids)
            if [ -n "$SERVICE_PIDS" ]; then
              kill $SERVICE_PIDS 2>/dev/null || true
              echo "✅ Services stopped"
            fi
          fi

  # Unit tests
  unit_tests:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python environment  
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: 'requirements.txt'

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run unit tests
        run: |
          echo "🧪 Running unit tests..."
          pytest -v --tb=short

  # Build and push Docker images
  build_and_push:
    needs: [contracts_lint, unit_tests]
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        service: [auth, profile, content, notifications, analytics, content-worker, chat]
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup environment variables
        run: |
          echo "OWNER_LC=${GITHUB_REPOSITORY_OWNER,,}" >> "$GITHUB_ENV"
          echo "SERVICE=${{ matrix.service }}" >> "$GITHUB_ENV"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: ./services/${{ matrix.service }}
          push: true
          cache-from: type=gha,scope=${{ matrix.service }}
          cache-to: type=gha,mode=max,scope=${{ matrix.service }}
          tags: |
            ghcr.io/${{ env.OWNER_LC }}/${{ matrix.service }}:${{ github.sha }}
            ghcr.io/${{ env.OWNER_LC }}/${{ matrix.service }}:${{ github.ref_name }}
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

  # Trigger deployment workflows
  trigger_deployments:
    needs: build_and_push
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Trigger environment-specific deployments
        run: |
          echo "🚀 Triggering deployment workflows..."
          
          # Determine target environment
          case "${{ github.ref }}" in
            "refs/heads/dev")
              ENVIRONMENT="dev"
              EVENT_TYPE="deploy-dev"
              ;;
            "refs/heads/main")
              ENVIRONMENT="staging"  
              EVENT_TYPE="deploy-staging"
              ;;
            refs/tags/release-*)
              ENVIRONMENT="prod"
              EVENT_TYPE="deploy-prod"
              ;;
            *)
              echo "No deployment configured for ref: ${{ github.ref }}"
              exit 0
              ;;
          esac
          
          echo "Target environment: $ENVIRONMENT"
          echo "Event type: $EVENT_TYPE"

      - name: Dispatch deployment event
        if: github.ref == 'refs/heads/dev' || github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/release-')
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          event-type: ${{ 
            github.ref == 'refs/heads/dev' && 'deploy-dev' ||
            github.ref == 'refs/heads/main' && 'deploy-staging' ||
            startsWith(github.ref, 'refs/tags/release-') && 'deploy-prod'
          }}
          client-payload: |
            {
              "sha": "${{ github.sha }}",
              "ref": "${{ github.ref }}",
              "environment": "${{ 
                github.ref == 'refs/heads/dev' && 'dev' ||
                github.ref == 'refs/heads/main' && 'staging' ||
                startsWith(github.ref, 'refs/tags/release-') && 'prod'
              }}",
              "tag": "${{ github.ref_name }}"
            }
