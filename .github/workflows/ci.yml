name: CI
on:
  push:
    branches: [ main, dev ]
    tags:
      - "release-*"
  pull_request:
    branches: [ main, dev ]

jobs:
  contracts_lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      # Install Spectral CLI for OpenAPI validation
      - name: Install Spectral CLI
        run: npm install -g @stoplight/spectral-cli
      
      # Start services in CI environment to generate live OpenAPI specs
      - name: Setup Python environment
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install Python dependencies
        run: |
          pip install fastapi uvicorn sqlalchemy psycopg2-binary redis jinja2
          pip install -r requirements.txt
          # Install service-specific requirements
          pip install -r services/notifications/requirements.txt
      
      - name: Start Services for OpenAPI Generation
        run: |
          echo "üöÄ Starting services for OpenAPI generation..."
          
          # Start Auth Service (port 8001)
          cd services/auth
          CI=true python -m uvicorn app.main:app --host 0.0.0.0 --port 8001 &
          AUTH_PID=$!
          echo "üîê Auth service started with PID: $AUTH_PID"
          
          # Start Profile Service (port 8002)
          cd ../profile
          python -m uvicorn app.main:app --host 0.0.0.0 --port 8002 &
          PROFILE_PID=$!
          echo "üë§ Profile service started with PID: $PROFILE_PID"
          
          # Start Analytics Service (port 8003)
          cd ../analytics
          python -m uvicorn app.main:app --host 0.0.0.0 --port 8003 &
          ANALYTICS_PID=$!
          echo "üìä Analytics service started with PID: $ANALYTICS_PID"
          
          # Start Notifications Service (port 8004)
          cd ../notifications
          python -m uvicorn app.main:app --host 0.0.0.0 --port 8004 &
          NOTIFICATIONS_PID=$!
          echo "üì¢ Notifications service started with PID: $NOTIFICATIONS_PID"
          
          # Wait for services to be ready
          echo "‚è≥ Waiting for services to be ready..."
          sleep 10
          
          # Health check all services
          echo "üîç Health checking services..."
          for port in 8001 8002 8003 8004; do
            echo "Checking port $port..."
            timeout 10s bash -c "until curl -s http://localhost:$port/healthz > /dev/null; do sleep 1; done" || echo "Service on port $port not ready"
          done
          
          echo "‚úÖ All services started and ready for OpenAPI generation"
      
      # Lint live OpenAPI specs from running services
      - name: Lint Live OpenAPI Specs
        run: |
          echo "üîç Linting live OpenAPI specs from running services..."
          
          # Additional wait to ensure services are fully ready
          sleep 5
          
          # Test OpenAPI endpoints before linting
          echo "üß™ Testing OpenAPI endpoints availability..."
          for port in 8001 8002 8003 8004; do
            echo "Testing port $port..."
            curl -s "http://localhost:$port/healthz" || echo "Health check failed for port $port"
          done
          
          # Lint each service's live OpenAPI spec with better error handling
          echo "üîê Linting Auth Service OpenAPI spec..."
          if curl -s "http://localhost:8001/api/auth/openapi.json" > /dev/null; then
            spectral lint "http://localhost:8001/api/auth/openapi.json" --ruleset libs/contracts/.spectral.yaml -f stylish -D --fail-severity=error || exit 1
            echo "‚úÖ Auth service OpenAPI spec validated"
          else
            echo "‚ùå Auth service OpenAPI endpoint not accessible"
            exit 1
          fi
          
          echo "üë§ Linting Profile Service OpenAPI spec..."
          if curl -s "http://localhost:8002/api/profile/openapi.json" > /dev/null; then
            spectral lint "http://localhost:8002/api/profile/openapi.json" --ruleset libs/contracts/.spectral.yaml -f stylish -D --fail-severity=error || exit 1
            echo "‚úÖ Profile service OpenAPI spec validated"
          else
            echo "‚ùå Profile service OpenAPI endpoint not accessible"
            exit 1
          fi
          
          echo "üìä Linting Analytics Service OpenAPI spec..."
          if curl -s "http://localhost:8003/api/analytics/openapi.json" > /dev/null; then
            spectral lint "http://localhost:8003/api/analytics/openapi.json" --ruleset libs/contracts/.spectral.yaml -f stylish -D --fail-severity=error || exit 1
            echo "‚úÖ Analytics service OpenAPI spec validated"
          else
            echo "‚ùå Analytics service OpenAPI endpoint not accessible"
            exit 1
          fi
          
          echo "üì¢ Linting Notifications Service OpenAPI spec..."
          if curl -s "http://localhost:8004/api/notifications/openapi.json" > /dev/null; then
            spectral lint "http://localhost:8004/api/notifications/openapi.json" --ruleset libs/contracts/.spectral.yaml -f stylish -D --fail-severity=error || exit 1
            echo "‚úÖ Notifications service OpenAPI spec validated"
          else
            echo "‚ùå Notifications service OpenAPI endpoint not accessible"
            exit 1
          fi
          
          echo "üéâ All live OpenAPI specs passed validation!"
          
          # Cleanup: Stop all services
          echo "üßπ Cleaning up services..."
          kill $AUTH_PID $PROFILE_PID $ANALYTICS_PID $NOTIFICATIONS_PID 2>/dev/null || true
          echo "‚úÖ Services cleaned up"

  unit_tests:
    needs: contracts_lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.x'
      - run: pip install -r requirements.txt
      - run: pytest -q

  build_and_push:
    needs: unit_tests
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [auth, profile, content, notifications, chat, analytics, content-worker]
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4

      - name: Derive lowercase owner for GHCR
        run: echo "OWNER_LC=${GITHUB_REPOSITORY_OWNER,,}" >> "$GITHUB_ENV"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build & push image
        uses: docker/build-push-action@v6
        with:
          context: ./services/${{ matrix.service }}
          push: true
          tags: |
            ghcr.io/${{ env.OWNER_LC }}/${{ matrix.service }}:${{ github.sha }}
            ghcr.io/${{ env.OWNER_LC }}/${{ matrix.service }}:${{ github.ref_name }}

  # Auto-deploy to dev environment when pushing to dev branch
  auto_deploy_dev:
    needs: build_and_push
    if: github.ref == 'refs/heads/dev' && github.event_name == 'push'
    runs-on: ubuntu-latest
    timeout-minutes: 60  # 1 hour timeout for entire deployment job
    environment: dev
    permissions:
      contents: read
      packages: read
      id-token: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Derive lowercase owner for GHCR
        run: echo "OWNER_LC=${GITHUB_REPOSITORY_OWNER,,}" >> "$GITHUB_ENV"

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4

      - name: Setup Helm
        uses: azure/setup-helm@v4

      - name: Configure kubeconfig from secret
        env:
          KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}
        run: |
          if [ -n "${KUBE_CONFIG:-}" ]; then
            mkdir -p "$HOME/.kube"
            echo "$KUBE_CONFIG" | base64 -d > "$HOME/.kube/config"
            echo "‚úì Wrote kubeconfig from secret"
          else
            echo "‚Ü∑ KUBE_CONFIG is empty; skipping. Add it as an Environment secret."
          fi

      - name: Create GHCR imagePullSecret
        env:
          NS: dev
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_PASSWORD: ${{ secrets.GHCR_TOKEN }}
        run: |
          set -euo pipefail
          if [ -n "${GHCR_USERNAME:-}" ] && [ -n "${GHCR_PASSWORD:-}" ]; then
            kubectl create namespace "$NS" --dry-run=client -o yaml | kubectl apply -f -
            kubectl -n "$NS" delete secret ghcr --ignore-not-found
            kubectl -n "$NS" create secret docker-registry ghcr \
              --docker-server=ghcr.io \
              --docker-username="$GHCR_USERNAME" \
              --docker-password="$GHCR_PASSWORD"
            echo "‚úì Created imagePullSecret 'ghcr' in namespace $NS"
          else
            echo "‚Ü∑ GHCR_USERNAME/GHCR_TOKEN not provided; skipping imagePullSecret creation."
          fi

      - name: Deploy api-gateway
        env:
          ENV: dev
          NS: dev
        run: |
          set -euo pipefail
          VALUES_FILE="deploy/helm/api-gateway/values.${ENV}.yaml"
          if [ -f "$VALUES_FILE" ]; then EXTRA_VALUES=(-f "$VALUES_FILE"); else EXTRA_VALUES=(); fi
          helm upgrade --install api-gateway deploy/helm/api-gateway \
            --namespace "$NS" --create-namespace \
            "${EXTRA_VALUES[@]}"

      - name: Deploy services
        env:
          ENV: dev
          NS: dev
        timeout-minutes: 30  # Explicit timeout for deployment step
        run: |
          set -euo pipefail
          
          echo "üöÄ Starting deployment of all services..."
          echo "üìä Services to deploy: auth, profile, content, notifications, chat, analytics, content-worker, swagger-ui"
          
          # Clean up any stuck operations first
          echo "üßπ Cleaning up any stuck Helm operations..."
          for svc in auth profile content notifications chat analytics content-worker swagger-ui; do
            # Check if there are any pending operations
            if helm status "$svc" -n "$NS" 2>/dev/null | grep -q "pending\|upgrading"; then
              echo "‚ö†Ô∏è Found pending operation for $svc, attempting to rollback..."
              if helm rollback "$svc" -n "$NS" --timeout 5m; then
                echo "‚úÖ Successfully rolled back $svc"
              else
                echo "‚ö†Ô∏è Rollback failed for $svc, will continue with deployment"
              fi
            fi
          done
          
          # Wait a bit for cleanup to complete
          echo "‚è≥ Waiting for cleanup to complete..."
          sleep 30
          
          # Function to check if a release is in progress
          check_release_status() {
            local svc=$1
            local status=$(helm status "$svc" -n "$NS" 2>/dev/null | grep -E "STATUS:|REVISION:" || echo "not_found")
            echo "$status"
          }
          
          # Function to wait for release to be ready
          wait_for_release() {
            local svc=$1
            local max_wait=300  # 5 minutes
            local wait_time=0
            local interval=10
            
            echo "‚è≥ Waiting for $svc release to be ready..."
            while [ $wait_time -lt $max_wait ]; do
              local status=$(helm status "$svc" -n "$NS" 2>/dev/null | grep "STATUS:" | awk '{print $2}' || echo "unknown")
              if [ "$status" = "deployed" ]; then
                echo "‚úÖ $svc release is ready"
                return 0
              elif [ "$status" = "failed" ]; then
                echo "‚ùå $svc release failed"
                return 1
              else
                echo "‚è≥ $svc release status: $status (waiting...)"
                sleep $interval
                wait_time=$((wait_time + interval))
              fi
            done
            echo "‚è∞ Timeout waiting for $svc release"
            return 1
          }
          
          # Track deployment progress
          DEPLOYED_SERVICES=()
          FAILED_SERVICES=()
          
          # Deploy core services first (those with migrations)
          echo "üîß Deploying core services with migrations..."
          for svc in auth profile content notifications; do
            echo "üîÑ Deploying $svc..."
            
            # Check if release is already in progress
            local release_status=$(check_release_status "$svc")
            if echo "$release_status" | grep -q "pending\|upgrading"; then
              echo "‚ö†Ô∏è $svc release is already in progress, waiting for completion..."
              if wait_for_release "$svc"; then
                echo "‚úÖ $svc was already being deployed and is now ready"
                DEPLOYED_SERVICES+=("$svc")
                continue
              else
                echo "‚ùå $svc release failed or timed out, will retry deployment"
              fi
            fi
            
            VALUES_FILE="deploy/helm/$svc/values.${ENV}.yaml"
            if [ -f "$VALUES_FILE" ]; then EXTRA_VALUES=(-f "$VALUES_FILE"); else EXTRA_VALUES=(); fi
            
            # Try deployment with retry logic
            local max_retries=2
            local retry_count=0
            local deploy_success=false
            
            while [ $retry_count -le $max_retries ] && [ "$deploy_success" = false ]; do
              if [ $retry_count -gt 0 ]; then
                echo "üîÑ Retry $retry_count/$max_retries for $svc..."
                # Wait a bit before retry
                sleep 30
              fi
              
              if helm upgrade --install "$svc" "deploy/helm/$svc" \
                --namespace "$NS" --create-namespace \
                --set "image.repository=ghcr.io/${{ env.OWNER_LC }}/$svc" \
                --set "image.tag=${{ github.sha }}" \
                --timeout 10m \
                "${EXTRA_VALUES[@]}"; then
                echo "‚úÖ $svc deployed successfully"
                DEPLOYED_SERVICES+=("$svc")
                deploy_success=true
              else
                echo "‚ùå $svc deployment attempt $((retry_count + 1)) failed"
                retry_count=$((retry_count + 1))
              fi
            done
            
            if [ "$deploy_success" = false ]; then
              echo "‚ùå $svc deployment failed after $max_retries retries"
              FAILED_SERVICES+=("$svc")
            fi
          done
          
          # Deploy remaining services
          echo "üîß Deploying remaining services..."
          for svc in chat analytics content-worker; do
            echo "üîÑ Deploying $svc..."
            VALUES_FILE="deploy/helm/$svc/values.${ENV}.yaml"
            if [ -f "$VALUES_FILE" ]; then EXTRA_VALUES=(-f "$VALUES_FILE"); else EXTRA_VALUES=(); fi
            
            if helm upgrade --install "$svc" "deploy/helm/$svc" \
              --namespace "$NS" --create-namespace \
              --set "image.repository=ghcr.io/${{ env.OWNER_LC }}/$svc" \
              --set "image.tag=${{ github.sha }}" \
              --timeout 5m \
              "${EXTRA_VALUES[@]}"; then
              echo "‚úÖ $svc deployed successfully"
              DEPLOYED_SERVICES+=("$svc")
            else
              echo "‚ùå $svc deployment failed"
              FAILED_SERVICES+=("$svc")
            fi
          done
          
          # Deploy Swagger UI separately (uses public image)
          echo "üîÑ Deploying swagger-ui..."
          if helm upgrade --install swagger-ui deploy/helm/swagger-ui \
            --namespace "$NS" --create-namespace \
            -f deploy/helm/swagger-ui/values.dev.yaml \
            --timeout 3m; then
            echo "‚úÖ swagger-ui deployed successfully"
            DEPLOYED_SERVICES+=("swagger-ui")
          else
            echo "‚ùå swagger-ui deployment failed"
            FAILED_SERVICES+=("swagger-ui")
          fi
          
          # Report deployment results
          echo "üìä Deployment Summary:"
          echo "‚úÖ Successfully deployed: ${DEPLOYED_SERVICES[*]:-none}"
          if [ ${#FAILED_SERVICES[@]} -gt 0 ]; then
            echo "‚ùå Failed services: ${FAILED_SERVICES[*]}"
            echo "::error::Some services failed to deploy"
            exit 1
          else
            echo "üéâ All services deployed successfully!"
          fi

      - name: Restart deployments to pick up ConfigMap changes
        env:
          NS: dev
        run: |
          set -euo pipefail
          echo "üîÑ Restarting deployments to ensure ConfigMap changes are applied..."
          
          # Restart all services that might have ConfigMap dependencies
          SERVICES_TO_RESTART=(api-gateway auth profile content notifications chat analytics content-worker swagger-ui)
          
          # Track successful and failed restarts
          RESTARTED_SERVICES=()
          FAILED_SERVICES=()
          
          # Restart each deployment
          for svc in "${SERVICES_TO_RESTART[@]}"; do
            echo "üîÑ Restarting deployment: $svc"
            if kubectl get deployment "$svc" -n "$NS" >/dev/null 2>&1; then
              if kubectl rollout restart "deployment/$svc" -n "$NS"; then
                echo "‚úì Successfully triggered restart for $svc"
                RESTARTED_SERVICES+=("$svc")
              else
                echo "‚ùå Failed to restart $svc"
                FAILED_SERVICES+=("$svc")
              fi
            else
              echo "‚ö†Ô∏è  Deployment $svc not found, skipping restart"
            fi
          done
          
          # Wait for all restarted deployments to complete
          echo "‚è≥ Waiting for all restarted deployments to be ready..."
          for svc in "${RESTARTED_SERVICES[@]}"; do
            echo "Waiting for $svc rollout to complete..."
            if kubectl rollout status "deployment/$svc" -n "$NS" --timeout=300s; then
              echo "‚úÖ $svc rollout completed successfully"
            else
              echo "‚ùå $svc rollout failed or timed out"
              FAILED_SERVICES+=("$svc")
            fi
          done
          
          # Report results
          echo "üìä Restart Summary:"
          echo "‚úÖ Successfully restarted: ${RESTARTED_SERVICES[*]:-none}"
          if [ ${#FAILED_SERVICES[@]} -gt 0 ]; then
            echo "‚ùå Failed services: ${FAILED_SERVICES[*]}"
            echo "::warning::Some services failed to restart properly"
          else
            echo "üéâ All deployments restarted successfully!"
          fi

